<!-- 
tessellation.html
Bennett Chang, Anna Leung
CSCI-510 
-->

<html>
<head>
    <title>CSCI-510: Final Project, L-System Tesselation</title>

    <!-- vertex Shader -->
<script id="shader" type="wgsl">
        struct VertexOutput {
            @builtin(position) aVertexPosition: vec4<f32>,
            @location(0) bary: vec3<f32>,
            @location(1) isGround: f32,
            @location(2) localPos: vec3<f32> // NEW: Store position for pattern
        };

        struct UniformStruct {
             theta : vec4<f32>,
             coralColor : vec4<f32>,
             cameraPos : vec4<f32>
        };

        @group(0) @binding(0) var<uniform> uniformStruct : UniformStruct;

        @vertex
        fn vs_main(@location(0) inPos: vec3<f32>,
                   @location(1) bary : vec3<f32>) -> VertexOutput {
            var out: VertexOutput;

            // 1. Standard Rotation Setup
            var c = cos(uniformStruct.theta);
            var s = sin(uniformStruct.theta);

            // 2. Camera & Transform Setup
            var trans = mat4x4<f32> ( 
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                uniformStruct.cameraPos.x, uniformStruct.cameraPos.y, 0.5, 1.0 
            );

            // Scale (kept at 0.35 to prevent clipping)
            var scale = mat4x4<f32> ( 
                0.35, 0.0, 0.0, 0.0,
                0.0, 0.35, 0.0, 0.0,
                0.0, 0.0, 0.35, 0.0,
                0.0, 0.0, 0.0, 1.0 
            );

            var rx = mat4x4<f32> ( 1.0, 0.0, 0.0, 0.0,
                             0.0, c.x, s.x, 0.0,
                             0.0, -s.x, c.x, 0.0,
                             0.0, 0.0, 0.0, 1.0 );

            var ry = mat4x4<f32> ( c.y, 0.0, -s.y, 0.0,
                             0.0, 1.0, 0.0, 0.0,
                             s.y, 0.0, c.y, 0.0,
                             0.0, 0.0, 0.0, 1.0 );

            var rz = mat4x4<f32> ( c.z, s.z, 0.0, 0.0,
                            -s.z, c.z, 0.0, 0.0,
                             0.0, 0.0, 1.0, 0.0,
                             0.0, 0.0, 0.0, 1.0 );

            let worldPos = trans * rz * ry * rx * scale * vec4<f32>(inPos, 1.0);

            out.aVertexPosition = worldPos;
            out.bary = bary;
            out.isGround = select(0.0, 1.0, inPos.y < -0.74);
            out.localPos = inPos; // Pass the local model position to fragment

            return out;
        }

        @fragment
        fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {

            // Define Base Sand Color
            let sandBase = vec4<f32>(0.95, 0.90, 0.65, 1.0);
            var finalColor = vec4<f32>(0.0);

            if (in.isGround > 0.5) {
                // --- SEABED PATTERN ---
                // Create a grid pattern using Sine waves on X and Z
                // We use localPos so the pattern stays stuck to the box
                let freq = 10.0; 
                let pattern = sin(in.localPos.x * freq) * sin(in.localPos.z * freq);
                
                // Mix between light and slightly dark sand based on pattern
                if (pattern > 0.0) {
                     finalColor = sandBase;
                } else {
                     finalColor = sandBase * 0.9; // Darker tile
                }
            } else {
                // --- CORAL GRADIENT ---
                let base = uniformStruct.coralColor.rgb;
                let h = clamp(in.bary.y + 0.5, 0.0, 1.0);
                let dark  = base * 0.4;
                let light = base + vec3<f32>(0.4);
                finalColor = vec4<f32>(mix(dark, light, h), 1.0);
            }

            // --- BLACK WIREFRAME ---
            if (in.bary.x < 0.02 || in.bary.y < 0.02 || in.bary.z < 0.02) {
                finalColor = vec4<f32>(0.0, 0.0, 0.0, 1.0); // Black
            }

            return finalColor;
        }
    </script>


    </script>
   
    <!-- include the shape creation functions -->
    <script type="text/javascript" src="./cgIShape.js"></script>

    <!-- include the main tesselation functions -->
    <script type="text/javascript" src="./tessMain.js"></script>

    <!-- keyboard functions -->
    <script type="text/javascript">

        function gotKey(event) {

            var key = event.key;

            //  incremental rotation
            if (key == 'x')
                angles[0] -= angleInc;
            else if (key == 'y')
                angles[1] -= angleInc;
            else if (key == 'z')
                angles[2] -= angleInc;
            else if (key == 'X')
                angles[0] += angleInc;
            else if (key == 'Y')
                angles[1] += angleInc;
            else if (key == 'Z')
                angles[2] += angleInc;

            // camera pan
            if (key == 'w' || key == 'W')
                camY += 0.1;
            else if (key == 's' || key == 'S')
                camY -= 0.1;
            else if (key == 'a' || key == 'A')
                camX -= 0.1;
            else if (key == 'd' || key == 'D')
                camX += 0.1;

            // shape selection
            else if (key == 'g' || key == 'G') {
                curShape = TREE;
                generateNewTree();
            }

            else if (key === 'b' || key === 'B') {
                coralMode = (coralMode + 1) % CORAL_BASE_COLORS.length;
            }


            // tessellation control
            else if (key == '+') {
                growthIterations++;
                generateNewTree();
            }

            else if (key == '=') {
                division2 = division2 + 1;
            }
            else if (key == '-') {
                if (growthIterations > 1) {
                    growthIterations--;
                    generateNewTree();
                }
            }
            else if (key == '_') {
                if (division2 > 1) {
                    division2 = division2 - 1;
                }
            }

            // reset
            else if (key == 'r' || key == 'R') {
                angles[0] = anglesReset[0];
                angles[1] = anglesReset[1];
                angles[2] = anglesReset[2];
                camX = 0.0;
                camY = 0.0;
            }

            // create a new shape and do a redo a draw
            createNewShape();
            draw();
        }

    </script>

    <script type="text/javascript">
        // Call init once the webpage has loaded
        window.onload = init;
    </script>
</head>

<body>
  <h1>CSCI-510: Final Project, L-System Tessellation</h1>
  <h2>Anna Leung & Bennett Chang</h2>
  <table>
      <tr>
          <td><canvas id="webgpu" width="800" height="800">
            Your browser does not support the HTML5 canvas element.
          </canvas></td>
          
          <td>
              <h3>Controls</h3>
              
              <table border="1">
              <tbody>
              <tr>
              <td>x, y, z</td>
              <td>Rotate the current shape forward about the x, y, or z axis</td>
              </tr>
              <tr>
              <td>X, Y, Z</td>
              <td>Rotate the current shape backward about the x, y, or z axis</td>
              </tr>
              <tr>
              <td>g, G</td>
              <td>Generate a new stochastic tree (using current tessellation settings)</td>
              </tr>
              <td>b</td>
              <td>Change coral color</td>
              </tr>
              <tr>
              <td>+, -</td>
              <td>Increment/decrement the primary subdivision of the current shape by 1</td>
              </tr>
              <tr>
              <td>=, _</td>
              <td>Increment/decrement the secondary subdivision of the current shape by 1</td>
              </tr>
              <tr>
              <td>r, R</td>
              <td>Reset the figure to its original orientation</td>
              </tr>
              </tbody>
              </table>
              
          </td>
      </tr>
  </table>
</body>
</html>