<html>
<head>
    <title>CSCI-510: Final Project, L-System Coral Tesselation</title>

    <!-- WGSL Shader: Handles vertex transformation and fragment coloring -->
    <script id="shader" type="wgsl">
        // Output structure passed from vertex to fragment shader
        struct VertexOutput {
            @builtin(position) aVertexPosition: vec4<f32>,  // Clip-space position
            @location(0) bary: vec3<f32>,                    // Barycentric coordinates for wireframe
            @location(1) isGround: f32,                      // Flag: 1.0 if ground/sand, 0.0 if coral
            @location(2) uv: vec2<f32>                       // Texture UV coordinates
        };

        // Uniform data shared across all shader instances
        struct UniformStruct {
             theta : vec4<f32>,       // Rotation angles: (rotX, rotY, rotZ, unused)
             coralColor : vec4<f32>,  // Base coral color (RGB) from mode selection
             cameraPos : vec4<f32>    // Camera position offset (X, Y, unused, unused)
        };

        // GPU resource bindings: uniforms, sampler, and textures
        @group(0) @binding(0) var<uniform> uniformStruct : UniformStruct;
        @group(0) @binding(1) var mySampler: sampler;            // Linear texture sampler
        @group(0) @binding(2) var sandTex: texture_2d<f32>;       // Sand texture for ground
        @group(0) @binding(3) var coralTex: texture_2d<f32>;      // Coral texture for vegetation

        // Vertex shader: transforms model space to clip space with camera control
        @vertex
        fn vs_main(@location(0) inPos: vec3<f32>,        // Vertex position
                   @location(1) bary : vec3<f32>,        // Barycentric coordinates
                   @location(2) inUv : vec2<f32>) -> VertexOutput {  // Texture UV
            var out: VertexOutput;

            // Orthographic projection matrix (fixed aspect ratio)
            let left = -2.0;   let right = 2.0;      // Horizontal bounds
            let bottom = -2.0; let top = 2.0;        // Vertical bounds
            let near = -5.0;   let far = 5.0;        // Depth range

            // Precomputed denominators for orthographic matrix
            let w = 1.0 / (right - left);
            let h = 1.0 / (top - bottom);
            let p = 1.0 / (far - near);

            // Orthographic projection matrix
            var proj = mat4x4<f32>(
                2.0 * w,  0.0,      0.0,      0.0,
                0.0,      2.0 * h,  0.0,      0.0,
                0.0,      0.0,      p,        0.0,
               -(right+left)*w, -(top+bottom)*h, -near*p, 1.0
            );

            // View matrix: applies camera pan offsets
            var view = mat4x4<f32>(
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                uniformStruct.cameraPos.x, uniformStruct.cameraPos.y, 0.0, 1.0
            );

            // Precompute sin/cos for rotation matrices
            var c = cos(uniformStruct.theta);
            var s = sin(uniformStruct.theta);

            // Rotation matrices around X, Y, Z axes
            var rx = mat4x4<f32> ( 1.0, 0.0, 0.0, 0.0, 0.0, c.x, s.x, 0.0, 0.0, -s.x, c.x, 0.0, 0.0, 0.0, 0.0, 1.0 );
            var ry = mat4x4<f32> ( c.y, 0.0, -s.y, 0.0, 0.0, 1.0, 0.0, 0.0, s.y, 0.0, c.y, 0.0, 0.0, 0.0, 0.0, 1.0 );
            var rz = mat4x4<f32> ( c.z, s.z, 0.0, 0.0, -s.z, c.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 );

            // Apply full transformation: rotation → view pan → projection
            let worldPos = proj * view * rz * ry * rx * vec4<f32>(inPos, 1.0);

            // Populate output structure
            out.aVertexPosition = worldPos;
            out.bary = bary;
            out.uv = inUv; 
            out.isGround = select(0.0, 1.0, inPos.y < -1.74);  // Classify terrain type based on Y coordinate

            return out;
        }

        // Fragment shader: determines final color based on terrain type and texture
        @fragment
        fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
            // Sample both textures upfront to ensure uniform control flow (required by some drivers)
            let sandColor = textureSample(sandTex, mySampler, in.uv);
            let coralTexColor = textureSample(coralTex, mySampler, in.uv);

            var finalColor = vec4<f32>(0.0);

            if (in.isGround > 0.5) {
                // Ground: Use sand texture directly
                finalColor = sandColor;
            } else {
                // Vegetation: Blend coral texture with procedural gradient for depth
                let base = uniformStruct.coralColor.rgb;
                let h = clamp(in.bary.y + 0.5, 0.0, 1.0);  // Height-based gradient
                
                // Create gradient from dark to light based on height
                let gradient = mix(base * 0.4, base + vec3<f32>(0.4), h);
                
                // Multiply texture color with procedural gradient for realistic shading
                finalColor = vec4<f32>(gradient * coralTexColor.rgb, 1.0);
            }

            // Draw black wireframe edges using barycentric coordinates
            // If any coordinate is near zero, pixel is near triangle edge
            if (in.bary.x < 0.02 || in.bary.y < 0.02 || in.bary.z < 0.02) {
                finalColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            }

            return finalColor;
        }
    </script>
   
    <script type="text/javascript" src="./cgIShape.js"></script>

    <script type="text/javascript" src="./tessMain.js"></script>

    <!-- JavaScript event handler for user input -->
    <script type="text/javascript">
        // Keyboard event handler: processes user input for rotation, camera pan, and shape manipulation
        function gotKey(event) {
            var key = event.key;

            // Rotation controls: x/y/z (backward), X/Y/Z (forward)
            if (key == 'x') angles[0] -= angleInc;
            else if (key == 'y') angles[1] -= angleInc;
            else if (key == 'z') angles[2] -= angleInc;
            else if (key == 'X') angles[0] += angleInc;
            else if (key == 'Y') angles[1] += angleInc;
            else if (key == 'Z') angles[2] += angleInc;

            // Camera pan controls: w/s for vertical, a/d for horizontal
            if (key == 'w' || key == 'W') camY += 0.1;
            else if (key == 's' || key == 'S') camY -= 0.1;
            else if (key == 'a' || key == 'A') camX -= 0.1;
            else if (key == 'd' || key == 'D') camX += 0.1;

            // Tree generation: g/G generates new stochastic tree
            else if (key == 'g' || key == 'G') {
                curShape = TREE;
                generateNewTree();
            }

            // Coral color cycling: b/B cycles through available colors
            else if (key === 'b' || key === 'B') {
                coralMode = (coralMode + 1) % CORAL_BASE_COLORS.length;
            }

            // L-System growth: +/- adjusts tree depth (iterations)
            else if (key == '+') {
                growthIterations++;
                updateTreeDepth();
            }

            // Tessellation subdivision: =/_ adjusts secondary subdivision level
            else if (key == '=') {
                division2 = division2 + 1;
            }
            else if (key == '-') {
                if (growthIterations > 1) {
                    growthIterations--;
                    updateTreeDepth();
                }
            }
            else if (key == '_') {
                if (division2 > 1) {
                    division2 = division2 - 1;
                }
            }

            // Reset: r/R restores default view and rotation
            else if (key == 'r' || key == 'R') {
                angles[0] = anglesReset[0];
                angles[1] = anglesReset[1];
                angles[2] = anglesReset[2];
                camX = 0.0;
                camY = 0.0;
            }

            // Regenerate shape and render with updated parameters
            createNewShape();
            draw();
        }
    </script>

    <!-- Initialize WebGPU context on page load -->
    <script type="text/javascript">
        window.onload = init;
    </script>
</head>

<body>
<h1>CSCI-510: Final Project, L-System Coral Tessellation</h1>
<h2>Anna Leung & Bennett Chang</h2>
<table>
    <tr>
        <!-- WebGPU Canvas: 800x800 rendering surface -->
        <td><canvas id="webgpu" width="800" height="800">
            Your browser does not support the HTML5 canvas element.
        </canvas></td>
        
        <td>
            <h3>Controls</h3>
            <!-- Interactive control reference: keyboard shortcuts and their effects -->
            <table border="1">
            <tbody>
            <tr>
            <td>x / y / z</td>
                <td>Rotate the current shape forward about the x, y, or z axis</td>
            </tr>
            <tr>
                <td>X / Y / Z</td>
                <td>Rotate the current shape backward about the x, y, or z axis</td>
            </tr>
            <tr>
                <td>g / G</td>
                <td>Generate a new stochastic tree (using current tessellation settings)</td>
            </tr>
            <td>b / B</td>
                <td>Change coral color</td>
            </tr>
            <tr>
            <td>+ / -</td>
                <td>Increment/decrement the primary subdivision of the current shape by 1</td>
            </tr>
            <tr>
                <td>= / _</td>
                <td>Increment/decrement the secondary subdivision of the current shape by 1</td>
            </tr>
            <tr>
                <td>r / R</td>
                <td>Reset the figure to its original orientation</td>
            </tr>
            <tr>
                <td>w / W, a / A, s / S, d / D</td>
                <td>Pan the camera up, left, down, right</td>
            </tr>
            </tbody>
            </table>
            
        </td>
    </tr>
</table>
</body>
</html>